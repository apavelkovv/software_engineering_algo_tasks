## Описание задачи
Реализуйте сортировку слиянием для массива целых чисел по возрастанию. Способ реализации на ваш выбор: можно использовать рекурсивный (top-down) или итеративный (bottom-up) вариант, можно сортировать на месте или возвращать новый массив.

## Требования
- Реализуйте функцию сортировки слиянием
- Разрешены любые варианты реализации: рекурсивный/итеративный, на месте/с возвратом нового массива
- Допускается использовать любые вспомогательные функции и структуры данных

## Ограничения
- Массив состоит из целых чисел, |value| ≤ 10^9
- Длина сортируемого диапазона: ≤ 10^5
- Асимптотика: время O(n log n), дополнительная память O(n) для слияния

## Формат ввода
- На вход функции подаётся массив `list[int]`

## Формат вывода
- Либо вернуть новый отсортированный массив, либо отсортировать входной массив на месте (выберите и зафиксируйте один вариант в решении)

## Пример
```
Вход:
[4, 5, 3, 0, 1, 2]

Возможный результат (полная сортировка):
[0, 1, 2, 3, 4, 5]
```

## Тесты
- Опишите от 5 тест кейсов, покрывающих:
  - пустой диапазон `[l, l)` и одноэлементный отрезок
  - уже отсортированный массив
  - массив, отсортированный в обратном порядке
  - наличие повторяющихся значений и отрицательных чисел
  - частичную сортировку подмассива внутри большого массива

```python
# Выберите и зафиксируйте один из интерфейсов ниже

# Вариант А: возвращать новый массив
def merge_sort(arr: list[int]) -> list[int]:
    ...


# Вариант Б: сортировать на месте
def merge_sort_inplace(arr: list[int]) -> None:
    ...


# пример тестов (для варианта А)
def test_return_new():
    assert merge_sort([]) == []
    assert merge_sort([3]) == [3]
    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert merge_sort([2, -1, 2, -1, 0]) == [-1, -1, 0, 2, 2]


# пример тестов (для варианта Б)
def test_inplace():
    arr = [4, 5, 3, 0, 1, 2]
    merge_sort_inplace(arr)
    assert arr == [0, 1, 2, 3, 4, 5]
```


